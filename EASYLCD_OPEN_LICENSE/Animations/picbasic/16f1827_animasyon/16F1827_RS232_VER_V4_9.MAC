
	NOLIST
; PICBASIC PRO(TM) Compiler 3.0.4.1, (c) 1998, 2011 microEngineering Labs, Inc. All Rights Reserved. 

LABEL?L macro Label
        RST?RP
    ifdef PM_USED
        LALL
Label
        XALL
    else
Label
    endif
    endm

ADD?BCB macro Bin, Cin, Bout
    if ((Bout) == (Bin))
      if ((Cin) == 1)
        CHK?RP  Bout
        incf    Bout, F
      else
        movlw   Cin
        CHK?RP  Bin
        addwf   Bin, F
      endif
    else
      if ((Cin) == 1)
        CHK?RP  Bin
        incf    Bin, W
        MOVE?AB Bout
      else
        movlw   Cin
        CHK?RP  Bin
        addwf   Bin, W
        MOVE?AB Bout
      endif
    endif
    endm

SUB?BCB macro Bin, Cin, Bout
    if ((Bout) == (Bin))
      if ((Cin) == 1)
        CHK?RP  Bout
        decf    Bout, F
      else
        movlw   Cin
        CHK?RP  Bout
        subwf   Bout, F
      endif
    else
      if ((Cin) == 1)
        CHK?RP  Bin
        decf    Bin, W
      else
        movlw   Cin
        CHK?RP  Bin
        subwf   Bin, W
      endif
        MOVE?AB Bout
    endif
    endm

LAND?BBW macro Bin1, Bin2, Wout
        MOVE?BB Bin1, FSR0L
        MOVE?BA Bin2
        L?CALL  LAND
        MOVE?AB Wout
        movwf   Wout + 1
    endm
LAND_USED = 1

LAND?WBW macro Win, Bin, Wout
        MOVE?BA Win
        iorwf   Win + 1, W
        movwf   FSR0L
        MOVE?BA Bin
        L?CALL  LAND
        MOVE?AB Wout
        movwf   Wout + 1
    endm
LAND_USED = 1

CMPF?WL macro Win, Label
        CLRWDT?
        MOVE?BA Win
        iorwf   (Win) + 1, W
        BIT?GOTO 1, STATUS, Z, Label
    endm

CMPEQ?BCB macro Bin, Cin, Bout
    if (((Cin) > -100h) & ((Cin) < 100h))
        MOVE?BA Bin
        sublw   Cin
	btfss	STATUS, Z
        movlw   -1
	xorlw	0ffh
        MOVE?AB Bout
    else
        CHK?RP  Bout
        clrf    Bout
    endif
    endm

CMPGT?BCB macro Bin, Cin, Bout
    if ((Cin) < 0)
        movlw   -1
        MOVE?AB Bout
    else
      if ((Cin) < 0ffh)
        MOVE?BB Bin, R0
        MOVE?CA Cin
        L?CALL  CMPGTB
        MOVE?AB Bout
      else
        CHK?RP  Bout
        clrf    Bout
      endif
    endif
    endm
CMPGTB_USED = 1

CMPGT?BCL macro Bin, Cin, Label
    if ((Cin) < 0)
        L?GOTO  Label
    else
      if ((Cin) < 0ffh)
        CLRWDT?
        MOVE?CA (Cin) + 1
        CHK?RP  Bin
        subwf   Bin, W
        BIT?GOTO 1, STATUS, C, Label
      endif
    endif
    endm

CMPNE?BCL macro Bin, Cin, Label
    if (((Cin) > -100h) & ((Cin) < 100h))
        CLRWDT?
        MOVE?BA Bin
        sublw   Cin
        BIT?GOTO 0, STATUS, Z, Label
    else
        L?GOTO  Label
    endif
    endm

DISABLE? macro
    endm

ENABLE? macro
    endm

END? macro
    local loop
loop    sleep
        L?GOTO  loop
    endm

GOSUB?L macro Label
    local dlabel
    ifdef DEBUG_STACK
        CHK?RP  DEBUG_STACK
      ifdef DEBUG_STACK_ADDR
        lslf    DEBUG_STACK, W
        addlw   DEBUG_STACK_ADDR
        movwf   FSR0L
        clrf    FSR0H
        movlw   low (dlabel)
        movwi   INDF0++
        movlw   (dlabel) >> 8
        movwf   INDF0
      endif
        incf    DEBUG_STACK, F
    endif
        L?CALL  Label
dlabel
    endm

GOTO?L macro Label
        L?GOTO  Label
    endm

HSERINTIME?C macro Cin
        MOVE?CW Cin, R6
    endm

HSERIN?BL macro Bout, Label
        L?CALL  HSERINTO
        BIT?GOTO 0, STATUS, C, Label
        MOVE?AB Bout
    endm
HSERINTO_USED = 1

HSERINWAIT?CLL macro Cin, Label1, Label2
        L?CALL  HSERINTO
        BIT?GOTO 0, STATUS, C, Label2
        sublw   Cin
        BIT?GOTO 0, STATUS, Z, Label1
    endm
HSERINTO_USED = 1

HSEROUT?C macro Cin
        movlw   Cin
        L?CALL  HSEROUT
    endm
HSEROUT_USED = 1

HSEROUTCOUNT?C macro Cin
        MOVE?CB Cin, R4 + 1
    endm

HSEROUTNUM?B macro Bin
        MOVE?BW Bin, R2
    endm

HSEROUTNUM?C macro Cin
        MOVE?CW Cin, R2
    endm

HSEROUTDEC? macro
        MOVE?CW HSEROUTJ, R8
        L?CALL  SEROUT2DEC
    endm
HSEROUTJ_USED = 1
SEROUT2DEC_USED = 1

HSEROUTHEX? macro
        MOVE?CW HSEROUTJ, R8
        L?CALL  SEROUT2HEX
    endm
HSEROUTJ_USED = 1
SEROUT2HEX_USED = 1

ICALL?L macro Label
        L?CALL  Label
    endm

NEXT?BCL macro Bin, Cin, Label
    if ((Cin) == 1)
        CHK?RP  Bin
      if ((PREV_BANK == 0) & (CODE_SIZE <= 2))
        incfsz  Bin, F
        goto    Label
      else
        incf    Bin, F
        BIT?GOTO 0, STATUS, Z, Label
      endif
    else
        movlw   Cin
        CHK?RP  Bin
        addwf   Bin, F
      if ((Cin) <= 255)
        BIT?GOTO 0, STATUS, C, Label
      endif
    endif
    endm

ONINT?LL macro Inthand, Intchk
    local label
        bsf     INTCON, GIE
        bra	label
Intchk  btfsc   INTCON, GIE
        return
        L?GOTO  Inthand
label
    endm
ONINT_USED = 1

PAUSE?C macro Cin
    if (((Cin) >> 8) == 0)
        MOVE?CA Cin
        L?CALL  PAUSE
    else
        MOVE?CB (Cin) >> 8, R1 + 1
        MOVE?CA low (Cin)
        L?CALL  PAUSEL
    endif
    endm
PAUSE_USED = 1

PAUSE?W macro Win
        MOVE?WWA Win, R1
        L?CALL  PAUSEL
    endm
PAUSE_USED = 1

PAUSEUS?C macro Cin
    if (((Cin) >> 8) == 0)
        movlw   Cin
        L?CALL  PAUSEUS
    else
        MOVE?CB (Cin) >> 8, R0 + 1
        MOVE?CA low (Cin)
        L?CALL  PAUSEUSL
    endif
    endm
PAUSEUS_USED = 1

RESUME? macro
        RST?RP
        retfie
    endm

RETURN? macro
    ifdef DEBUG_STACK
        CHK?RP  DEBUG_STACK
        decf    DEBUG_STACK, F
    endif
        RST?RP
        return
    endm


	LIST
